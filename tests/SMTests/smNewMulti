from multiprocessing import Lock, Manager, Process, Queue
from queue import Empty
from time import perf_counter_ns, sleep
from tqdm import tqdm

from algmatch.stableMarriageProblem import StableMarriageProblem

from instanceGenerator import SMInstanceGenerator as InstanceGenerator
from minmaxSMs import MMSMS


class MultiVerifyCorrectness:
    def __init__(self, total_men, total_women,
                 lower_bound, upper_bound,
                 reps, buffer_size):
        """
        It takes argument as follows (set in init):
            number of men
            number of women
            lower bound of the preference list length
            upper bound of the preference list length
            reps total
            result_dict, a shared object between threads
        """

        self._total_men = total_men
        self._total_women = total_women
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound

        self._reps = reps
        self.manager = Manager()

        self.result_dict = self.manager.dict()
        self.result_dict['correct'] = 0
        self.result_dict['incorrect'] = 0
        self.result_dict['total'] = 0

        self.q = Queue(buffer_size)
        self.res_lock = Lock()

        self.gen = InstanceGenerator(self._total_men, self._total_women, self._lower_bound, self._upper_bound)

        self._correct_count = 0
        self._incorrect_count = 0

    def produce_instances(self):
        products = 0
        while products < self._reps:
            if not self.q.full():
                self.q.put(self.gen.generate_instance_no_ties())
                products += 1
            else:
                sleep(0.001)

    def verify_instance(self, inst):

        minmaxer = MMSMS(dictionary=inst)
        man_optimal_solver = StableMarriageProblem(dictionary=inst, optimisedSide="men")
        woman_optimal_solver = StableMarriageProblem(dictionary=inst, optimisedSide="women")

        minmaxer.find_minmax_matchings()
        m_0 = man_optimal_solver.get_stable_matching()
        m_z = woman_optimal_solver.get_stable_matching()

        return m_z == minmaxer.minmax_matchings[-1] and m_0 == minmaxer.minmax_matchings[0]
    

    def run_instances(self):
        local_correct = 0
        local_incorrect = 0

        while self.result_dict['total'] < self._reps:
            try:
                instance = self.q.get(timeout=1)
            except Empty:
                break
            if self.verify_instance(instance):
                local_correct += 1
                with self.res_lock:
                    self.result_dict['correct'] += 1
                    self.result_dict['total'] += 1
            else:
                local_incorrect += 1
                with self.res_lock:
                    self.result_dict['incorrect'] += 1
                    self.result_dict['total'] += 1
        
    def show_results(self):
        print(f"""
            Total men: {self._total_men}
            Total women: {self._total_women}
            Preference list length lower bound: {self._lower_bound}
            Preference list length upper bound: {self._upper_bound}
            Repetitions: {self.result_dict['total']}

            Correct: {self.result_dict['correct']}
            Incorrect: {self.result_dict['incorrect']}
              """)

def main():
    n=5
    TOTAL_MEN = n
    TOTAL_WOMEN = n
    LOWER_LIST_BOUND = n
    UPPER_LIST_BOUND = n
    REPETITIONS = 12000
    THREADS = 12
    BUFFER_SIZE = 20

    start = perf_counter_ns()

    verifier = MultiVerifyCorrectness(TOTAL_MEN, TOTAL_WOMEN,
                                        LOWER_LIST_BOUND, UPPER_LIST_BOUND,
                                        REPETITIONS, BUFFER_SIZE)
    v_threads = []

    producer = Process(target=verifier.produce_instances)
    v_threads.append(producer)
    for _ in range(THREADS):
        thread = Process(target=verifier.run_instances)
        v_threads.append(thread)

    for v_t in v_threads:
        v_t.start()

    with tqdm(total=REPETITIONS) as pbar:
        while any(thread.is_alive() for thread in v_threads):
            sleep(0.25)
            pbar.n = verifier.result_dict["total"]
            pbar.last_print_n = pbar.n
            pbar.update(0)

    print("go to join")
    for v_t in v_threads:
        v_t.join()
    print("join success")
        
    end = perf_counter_ns()
    print(f"\n{(end-start)/1000**3}s")

    verifier.show_results()

if __name__ == '__main__':
    main()